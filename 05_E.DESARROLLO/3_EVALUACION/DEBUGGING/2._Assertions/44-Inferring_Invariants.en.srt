1
00:00:00,000 --> 00:00:06,000
Establecer condiciones previas, condiciones posteriores e invariantes adecuados puede ser una tarea difícil.

2
00:00:06,000 --> 00:00:08,000
Existen otras herramientas que nos ayudan a hacerlo,

3
00:00:08,000 --> 00:00:14,000
como la idea de inferir invariantes, teniendo una herramienta que proporcione automáticamente

4
00:00:14,000 --> 00:00:18,000
invariantes de datos, precondiciones y postcondiciones.

5
00:00:18,000 --> 00:00:21,000
Voy a mostrarte cómo funcionan estas herramientas

6
00:00:21,000 --> 00:00:23,000
y vamos a explorar cómo construir una.

7
00:00:23,000 --> 00:00:27,000
La herramienta Daikon de Michael Ernst y colegas es una herramienta

8
00:00:27,000 --> 00:00:30,000
que detecta dinámicamente invariantes de ejecuciones de programas.

9
00:00:30,000 --> 00:00:33,000
La idea es que tienes un conjunto de ejecuciones.

10
00:00:33,000 --> 00:00:35,000
Aquí tienes una ejecución.

11
00:00:35,000 --> 00:00:38,000
Aquí tienes otra, y aquí tienes cinco ejecuciones.

12
00:00:38,000 --> 00:00:42,000
Lo que Daikon hace es analizar estas ejecuciones y verificar

13
00:00:42,000 --> 00:00:47,000
si existen propiedades o variables que se mantienen para todas las ejecuciones observadas.

14
00:00:47,000 --> 00:00:51,000
Por ejemplo, podría determinar que la variable x es impar

15
00:00:51,000 --> 00:00:54,000
siempre que se llama a la función f.

16
00:00:54,000 --> 00:00:56,000
¿Cómo lo hace Daikon?

17
00:00:56,000 --> 00:00:58,000
Lo primero que hace es obtener trazas.

18
00:00:58,000 --> 00:01:02,000
Una traza es una lista de todas las funciones que se llamaron

19
00:01:02,000 --> 00:01:05,000
y todos los valores de todas las variables.

20
00:01:05,000 --> 00:01:09,000
Muy similar a la función sys.settrace() en Python,

21
00:01:09,000 --> 00:01:12,000
que hemos utilizado para rastrear programas.

22
00:01:12,000 --> 00:01:16,000
Lo que Daikon tiene incorporado es una llamada biblioteca de patrones.

23
00:01:16,000 --> 00:01:18,000
Una biblioteca de posibles invariantes.

24
00:01:18,000 --> 00:01:21,000
Aquí hay un patrón: $1 == 0.

25
00:01:21,000 --> 00:01:25,000
Aquí hay un patrón: tenemos un marcador de posición que es igual a 0.

26
00:01:25,000 --> 00:01:28,000
Daikon ahora toma la traza, observa todas las variables,

27
00:01:28,000 --> 00:01:31,000
y verifica qué variable satisface este patrón.

28
00:01:31,000 --> 00:01:36,000
Es decir, reemplaza el marcador de posición con cada variable encontrada en la traza.

29
00:01:36,000 --> 00:01:44,000
Verifica si x == 0, si y == 0, si z == 0, y así sucesivamente.

30
00:01:44,000 --> 00:01:47,000
Solo se retienen los patrones que coinciden.

31
00:01:47,000 --> 00:01:49,000
Los que no coinciden se eliminan.

32
00:01:49,000 --> 00:01:54,000
X e y no son 0. Entonces se eliminan. Este se retiene.

33
00:01:54,000 --> 00:01:57,000
Daikon verifica estos patrones para cada invocación de función

34
00:01:57,000 --> 00:02:01,000
y solo retiene aquellos que se mantienen para todas las invocaciones de la función,

35
00:02:01,000 --> 00:02:05,000
lo que significa que, con el tiempo, el conjunto de patrones instanciados se vuelve

36
00:02:05,000 --> 00:02:08,000
cada vez más pequeño. Es como un tamiz.

37
00:02:08,000 --> 00:02:13,000
Al final, si se encuentra que esta instanciación se mantiene para todas las invocaciones de una función,

38
00:02:13,000 --> 00:02:17,000
entonces se retiene y finalmente se informa como un invariante.

39
00:02:17,000 --> 00:02:19,000
Daikon tiene cientos de estos patrones.

40
00:02:19,000 --> 00:02:24,000
Los prueba todos uno por uno en todas las variables en todas las invocaciones.

41
00:02:24,000 --> 00:02:26,000
Sí, esto toma un poco de tiempo.

42
00:02:26,000 --> 00:02:30,000
Si, al aplicar la biblioteca de patrones, Daikon ha descubierto

43
00:02:30,000 --> 00:02:33,000
que x es siempre impar cuando se llama a f,

44
00:02:33,000 --> 99:59:59,000
lo informa como un invariante.